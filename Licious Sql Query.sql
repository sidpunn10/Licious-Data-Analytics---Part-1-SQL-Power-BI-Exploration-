--LICIOUS PROJECT ON CUSTOMER ANALYTICS
USE LICIOUS

SELECT 
    Address, 
    LTRIM(RIGHT(CAST(Address AS VARCHAR(8000)), 
                LEN(CAST(Address AS VARCHAR(8000))) - CHARINDEX(',', CAST(Address AS VARCHAR(8000))))) AS City
FROM CUSTOMERS;


SELECT * FROM ORDERS
SELECT * FROM PRODUCTS
SELECT * FROM CUSTOMERS

SELECT DISTINCT CATEGORY FROM PRODUCTS

select count(ORDER_ID) FROM ORDERS

SELECT NAME,SUM(TOTAL_AMOUNT) FROM CUSTOMERS C
JOIN ORDERS O ON C.CUSTOMER_ID =O.CUSTOMER_ID
GROUP BY NAME
ORDER BY SUM(TOTAL_AMOUNT) DESC




SELECT COUNT(*) FROM ORDERS
SELECT COUNT(*) FROM PRODUCTS
SELECT COUNT(*) FROM CUSTOMERS

--Rank products within each category by total revenue, showing their revenue contribution percentage using a window function.

WITH CTE AS 
(

SELECT SUM(TOTAL_AMOUNT) AS REVENUE,
P.PRODUCT_ID,NAME AS PRODUCT_NAME,CATEGORY
FROM PRODUCTS P
INNER JOIN ORDERS O
ON P.PRODUCT_ID =O.PRODUCT_ID
GROUP BY P.PRODUCT_ID,NAME,CATEGORY
)

SELECT PRODUCT_NAME,PRODUCT_ID,REVENUE,CATEGORY,DENSE_RANK() OVER (PARTITION BY CATEGORY ORDER BY REVENUE DESC) AS RK,
SUM(SUM(REVENUE)) OVER(PARTITION BY CATEGORY) * 100 AS REVENUE_PERCENTAGE
FROM CTE 
GROUP BY PRODUCT_NAME,PRODUCT_ID,REVENUE,CATEGORY

--2.	Calculate the time interval (in days) between consecutive orders for each customer using LAG, and find the average interval.
WITH CTE AS (

SELECT C.CUSTOMER_ID,NAME AS CUSTOMER_NAME,
ORDER_DATE AS CURRENT_ORDER_DATE  ,
LAG(ORDER_DATE) OVER (PARTITION BY C.CUSTOMER_ID ORDER BY ORDER_DATE) AS PREVIOUS_ORDER_DATE FROM ORDERS  O
JOIN CUSTOMERS C 
ON C.CUSTOMER_ID =O.CUSTOMER_ID
),
INTERVAL AS (
SELECT *,DATEDIFF(DAY,PREVIOUS_ORDER_DATE,CURRENT_ORDER_DATE) AS INTERVAL FROM CTE 
WHERE DATEDIFF(DAY,PREVIOUS_ORDER_DATE,CURRENT_ORDER_DATE) IS NOT NULL 
AND DATEDIFF(DAY,PREVIOUS_ORDER_DATE,CURRENT_ORDER_DATE) <> 0
)

SELECT DISTINCT CUSTOMER_NAME,CUSTOMER_ID , AVG(INTERVAL) AS AVG_INTERVAL FROM INTERVAL
GROUP BY CUSTOMER_NAME,CUSTOMER_ID
ORDER BY AVG_INTERVAL

--3 	Using LEAD, find the next order date and product for each customer.
WITH CTE AS (
SELECT DISTINCT C.NAME,
LEAD(ORDER_DATE) OVER(PARTITION BY C.CUSTOMER_ID ORDER BY ORDER_DATE) AS NEXT_ORDER_DATE,
LEAD(P.NAME) OVER (PARTITION BY C.CUSTOMER_ID ORDER BY ORDER_DATE) AS NEXT_PRODUCT
FROM ORDERS O 
JOIN CUSTOMERS C
ON O.CUSTOMER_ID =C.CUSTOMER_ID
JOIN PRODUCTS P
ON P.PRODUCT_ID =O.PRODUCT_ID
)

SELECT * FROM CTE

--4 	Calculate the running total of revenue for each customer over time using a window function.

WITH CTE AS 
(
SELECT DISTINCT NAME,ORDER_DATE,
--SUM(TOTAL_AMOUNT)  AS TOTAL_REVENUE,
SUM(TOTAL_AMOUNT) OVER (PARTITION BY NAME ORDER BY ORDER_DATE) AS RUNNING_TOTAL
FROM CUSTOMERS C
JOIN ORDERS O
ON C.CUSTOMER_ID =O.CUSTOMER_ID

)

SELECT * FROM CTE ORDER  BY RUNNING_TOTAL DESC

--5 	Find the top 3 products by revenue in each city using window functions and joins.

WITH CTE AS (

SELECT C.NAME AS CUSTOMER_NAME,SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,P.NAME AS PRODUCT_NAME,CAST(ADDRESS AS VARCHAR)  CUST_ADD
FROM CUSTOMERS C
INNER JOIN  ORDERS O
ON C.CUSTOMER_ID =O.CUSTOMER_ID
INNER JOIN PRODUCTS P 
ON P.PRODUCT_ID =O.PRODUCT_ID
GROUP BY C.NAME,P.NAME,CAST(ADDRESS AS VARCHAR) 
)
,
CTE2 AS (
SELECT * , 
    LTRIM(RIGHT(CAST(CUST_ADD AS VARCHAR(8000)), 
                LEN(CAST(CUST_ADD AS VARCHAR(8000))) - CHARINDEX(',', CAST(CUST_ADD AS VARCHAR(8000))))) AS City
FROM CTE
)
SELECT CUSTOMER_NAME,TOTAL_REVENUE,PRODUCT_NAME,CITY FROM (
SELECT CUSTOMER_NAME,TOTAL_REVENUE,PRODUCT_NAME,CITY,ROW_NUMBER() OVER (PARTITION BY CITY ORDER BY TOTAL_REVENUE DESC) AS RN
FROM CTE2) A
WHERE CITY IS NOT NULL
AND RN<=3

--6.	Calculate the month-over-month revenue growth percentage for each product category using LAG.

WITH CTE AS
(
SELECT CATEGORY,SUM(TOTAL_AMOUNT) AS TOT_REV,
MONTH(ORDER_DATE) AS MONTHS,
YEAR(ORDER_DATE) AS YEARS FROM 
PRODUCTS P
JOIN ORDERS O
ON P.PRODUCT_ID =O.PRODUCT_ID
GROUP BY CATEGORY,MONTH(ORDER_DATE),YEAR(ORDER_DATE)
)
,
PREV_REV AS (
SELECT CATEGORY,TOT_REV,MONTHS,YEARS,LAG(TOT_REV) OVER (PARTITION BY CATEGORY ORDER BY MONTHS,YEARS) AS PREVIOUS_REV FROM CTE
)

SELECT CATEGORY,TOT_REV,MONTHS,PREVIOUS_REV,YEARS,(TOT_REV-PREVIOUS_REV)/PREVIOUS_REV*100 AS REV_PERCENTAGE FROM PREV_REV
ORDER BY (TOT_REV-PREVIOUS_REV)/PREVIOUS_REV*100  DESC

--7.	Calculate the cumulative quantity sold for each product over time, partitioned by category.

SELECT DISTINCT P.PRODUCT_ID,NAME AS PRODUCT_NAME,
CATEGORY,ORDER_DATE,
SUM(QUANTITY) OVER (PARTITION BY CATEGORY ORDER BY ORDER_DATE ) AS CUM_QUANTITY
FROM PRODUCTS P
JOIN ORDERS O
ON P.PRODUCT_ID =O.PRODUCT_ID


-- 8 	Find customers whose average order value has increased over the last 3 months compared to the previous 3 months.

WITH MONTHLY_AVG_ORDER AS 
(

SELECT C.CUSTOMER_ID,DATEPART(MONTH,ORDER_DATE) AS ORDER_MONTH,C.NAME AS CUSTOMER_NAME,ORDER_DATE,
DATEPART(YEAR,ORDER_DATE) AS ORDER_YEAR,
ROUND(AVG(TOTAL_AMOUNT),2) AS AVG_TOT_AMOUNT
FROM CUSTOMERS C
JOIN ORDERS O 
ON C.CUSTOMER_ID =O.CUSTOMER_ID
WHERE ORDER_DATE >= DATEADD(MONTH,-6,GETDATE())
GROUP BY C.CUSTOMER_ID,DATEPART(MONTH,ORDER_DATE),DATEPART(YEAR,ORDER_DATE),ORDER_DATE,C.NAME
)
,
PERIODAVG AS (
SELECT CUSTOMER_ID,
AVG(CASE WHEN ORDER_DATE >= DATEADD(MONTH,-3,GETDATE()) THEN AVG_TOT_AMOUNT END) AS LAST_MONTH_AVG_3,
AVG(CASE WHEN ORDER_DATE <DATEADD(MONTH,-3,GETDATE()) THEN AVG_TOT_AMOUNT END) AS PREVIOUS_3_MONTH_AVG
FROM MONTHLY_AVG_ORDER
GROUP BY CUSTOMER_ID
)

SELECT CUSTOMER_ID,LAST_MONTH_AVG_3,PREVIOUS_3_MONTH_AVG,(LAST_MONTH_AVG_3-PREVIOUS_3_MONTH_AVG)/PREVIOUS_3_MONTH_AVG*100 AS GROWTH_PERC FROM PERIODAVG
WHERE (LAST_MONTH_AVG_3-PREVIOUS_3_MONTH_AVG)/PREVIOUS_3_MONTH_AVG*100  IS NOT NULL

--9.	Rank customers by their total spending within each city using a window function.

WITH CUSTOMER_SPEND AS
(
SELECT CUSTOMER_ID,NAME AS CUSTOMER_NAME,ADDRESS,
LTRIM(RIGHT(CAST(Address AS VARCHAR(8000)), 
                LEN(CAST(Address AS VARCHAR(8000))) - CHARINDEX(',', CAST(Address AS VARCHAR(8000))))) AS City
				FROM CUSTOMERS
				),
CITY_CTE AS (
	SELECT C.CUSTOMER_ID,CUSTOMER_NAME,City,SUM(TOTAL_AMOUNT) AS TOT_AMOUNT FROM CUSTOMER_SPEND C
	INNER JOIN ORDERS O
	ON O.CUSTOMER_ID =C.CUSTOMER_ID
	WHERE CITY IS NOT NULL
	GROUP BY C.CUSTOMER_ID,CUSTOMER_NAME,City
	)
	SELECT CUSTOMER_ID,CUSTOMER_NAME,CITY,TOT_AMOUNT FROM (
	SELECT *,DENSE_RANK() OVER (PARTITION BY CITY ORDER BY TOT_AMOUNT DESC) AS RN FROM CITY_CTE
	)A WHERE RN=1

	--10.	Calculate the percentage of total revenue contributed by each order within a customer’s order history.
	WITH CTE AS (
	SELECT C.CUSTOMER_ID,NAME AS CUSTOMER_NAME,
	SUM(TOTAL_AMOUNT) AS TOT_REV,
	ORDER_DATE
	FROM ORDERS O
	JOIN CUSTOMERS C
	ON O.CUSTOMER_ID =C.CUSTOMER_ID
	GROUP BY C.CUSTOMER_ID,NAME,ORDER_DATE
	)


SELECT TOT_REV/SUM(TOT_REV) OVER (PARTITION BY CUSTOMER_ID)*100  AS PERCENT_CUST,CUSTOMER_NAME,ORDER_DATE FROM CTE
ORDER BY ORDER_DATE DESC

--11.	For each product, calculate the average time interval between orders, grouped by category.

WITH ORDER_INTERVAL AS 
(
SELECT DISTINCT P.PRODUCT_ID,NAME AS PRODUCT_NAME,
CATEGORY,ORDER_DATE ,LAG(ORDER_DATE) OVER (PARTITION BY P.PRODUCT_ID ORDER BY ORDER_DATE) AS PREVIOUS_ORDER
FROM ORDERS O 
JOIN PRODUCTS P
ON P.PRODUCT_ID =O.PRODUCT_ID
),
DAYS_BETWEEN_ORDERS AS (
SELECT PRODUCT_ID,PRODUCT_NAME,DATEDIFF(DAY,PREVIOUS_ORDER,ORDER_DATE) AS DAYS_BETWEEN_ORDER,CATEGORY
FROM ORDER_INTERVAL 
)

SELECT PRODUCT_ID,PRODUCT_NAME,AVG(DAYS_BETWEEN_ORDER) AS TIME_INTRVAL_BETWEEN_ORDER,CATEGORY FROM DAYS_BETWEEN_ORDERS
GROUP BY  PRODUCT_ID,PRODUCT_NAME,CATEGORY
--WHERE DAYS_BETWEEN_ORDERS IS NOT NULL

--12.	Identify products where the stock quantity has dropped below 10% of its initial value after a specific order using window functions.
WITH CTE AS
(
SELECT PRODUCT_ID,STOCK_QUANTITY AS INTIAL_STOCK
FROM PRODUCTS  WHERE STOCK_QUANTITY =(SELECT MAX(STOCK_QUANTITY) FROM PRODUCTS P2
WHERE P2.PRODUCT_ID =PRODUCTS.PRODUCT_ID
)

SELECT * FROM CTE

--13.	Calculate the average preparation time of products ordered by each customer, ranked within their city.

WITH CUSTOMER_CTE AS 
(

SELECT CUSTOMER_ID,NAME AS CUSTOMER_NAME,
Address, 
    LTRIM(RIGHT(CAST(Address AS VARCHAR(8000)), 
                LEN(CAST(Address AS VARCHAR(8000))) - CHARINDEX(',', CAST(Address AS VARCHAR(8000))))) AS City
				FROM CUSTOMERS
				),

ORDERS_CTE AS (
	SELECT C.CUSTOMER_ID,C.CUSTOMER_NAME,CITY,TOTAL_AMOUNT,PRODUCT_ID FROM CUSTOMER_CTE C
	JOIN ORDERS O
	ON C.CUSTOMER_ID =O.CUSTOMER_ID
				)
				
				SELECT CUSTOMER_ID,CUSTOMER_NAME,CITY,DENSE_RANK()OVER (PARTITION BY CITY ORDER BY AVG_PREPARATION_TIME  DESC) AS RANK,AVG_PREPARATION_TIME FROM (
				SELECT DISTINCT CUSTOMER_ID,CUSTOMER_NAME,CITY,AVG(PREPARATION_TIME) AS AVG_PREPARATION_TIME FROM ORDERS_CTE O
				JOIN PRODUCTS P 
				ON P.PRODUCT_ID =O.PRODUCT_ID
				WHERE CITY IS NOT NULL
				GROUP BY  CUSTOMER_ID,CUSTOMER_NAME,CITY
				)A
				

	--14.	For each customer, calculate the cumulative revenue contribution by order status over time.

	WITH CUM_REV AS 
	(

	SELECT C.CUSTOMER_ID,NAME AS CUSTOMER_NAME,SUM(TOTAL_AMOUNT) OVER ( ORDER BY ORDER_DATE) AS CUM_SUM,STATUS,ORDER_DATE
	FROM ORDERS O
	JOIN CUSTOMERS C
	ON O.CUSTOMER_ID =C.CUSTOMER_ID
	)

	SELECT * FROM CUM_REV WHERE STATUS  IS NOT NULL

	--15 15.	Classify customers into loyalty tiers based on their total spending and order frequency in the last 6 months, 
	--using CASE WHEN. Assign tiers as 'Platinum' (total spending > 5000 AND order count > 3), 
	--'Gold' (total spending > 3000 AND order count > 5), 'Silver' (total spending > 1000 AND order count > 2), 
	--or 'Bronze' (all others). Include the total spending and order count in the results

	WITH CTE_CUSTOMER AS 
	(

	SELECT SUM(TOTAL_AMOUNT) AS TOT_REV,
	QUANTITY AS ORDER_FREQ,
	C.CUSTOMER_ID,NAME AS CUSTOMER_NAME
	FROM CUSTOMERS C
	JOIN ORDERS O
	ON O.CUSTOMER_ID =C.CUSTOMER_ID
	WHERE ORDER_DATE >= DATEADD(MONTH,-6,GETDATE())
	GROUP BY QUANTITY,C.CUSTOMER_ID,NAME
	
	)

	SELECT * ,
	CASE WHEN TOT_REV >5000 AND ORDER_FREQ >3 THEN 'PLATINUM'
	WHEN TOT_REV >3000 AND ORDER_FREQ >2 THEN 'GOLD'
	ELSE 'BRONZE' END AS LOYALTY_TIERS
	FROM CTE_CUSTOMER

	--16 Identify the busiest day of the week for orders in each month over the past year, using date/time functions to extract the day name and rank days by order count. 
	--Use window functions to rank days within each month and year, and return only the top day per month.

	WITH DAILY_ORDER AS (
	SELECT YEAR(ORDER_DATE) AS YEARS,
	MONTH(ORDER_DATE) AS MONTHS,
	DATENAME(WEEKDAY,ORDER_DATE) AS DAY_OF_WEEK,
	COUNT(*) AS NO_OF_ORDERS FROM ORDERS
	WHERE ORDER_DATE >= DATEADD(YEAR,-1,GETDATE())
	GROUP BY YEAR(ORDER_DATE),MONTH(ORDER_DATE),DATENAME(WEEKDAY,ORDER_DATE) 
	--ORDER BY NO_OF_ORDERS DESC
	)

	SELECT YEARS,MONTHS,DAY_OF_WEEK,NO_OF_ORDERS FROM (
	SELECT *,RANK() OVER (PARTITION BY YEARS,MONTHS ORDER BY NO_OF_ORDERS DESC) AS RN FROM DAILY_ORDER
	)A 
	WHERE RN=1
				






 